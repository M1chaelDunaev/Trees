В данном заголовочном файле представлены 3 вида бинарных деревьев поиска:
	Tree<KeyType, ValueType> - Рандомизированное бинарное дерево поиска.
	AVLTree<KeyType, ValueType> - АВЛ дерево.
	RBTree<KeyType, ValueType> - Красно-черное дерево.

*Параметр шаблона KeyType является концептом(для работы необходимо выставить стандарт C++20)
	и требует, чтобы тип ключа поддерживал операции < , == , > 


Описание класса Iterator:

	std::pair<KeyType, ValueType&> operator * - Возвращает пару где first - значение ключа, а second - ссылка на значение
		узла с этим ключом.
	void operator ++ - Переводит итератор на следующий узел в порядке возрастания.
	void operator -- - Переводит итератор на предыдущий узел в порядке возрастания.
	bool operator == - Возвращает true если оба итератора указывают на один и тот же узел, false если нет.

Описание public методов:
	
	Constructors:
		tree() - Создает пустое дерево.
		tree(KeyType, ValueType) - создает дерево с 1 узлом с переданными параметрами.
		tree(std::pair<KeyType, ValueType>) - создает дерево с 1 узлом с элементами пары.
		tree(std::vector<std::pair<KeyType, ValueType>)

	int size() - Возвращает количество узлов дерева.
	bool empty() - Возвращает true, если дерево пустое.

	bool insert(const KeyType&, ValueType&) - Добавляет новый узел в дерево, возвращает true в случае успеха.
	bool insert(std::pair<KeyType, ValueType>) - Добавляет новый узел в дерево, возвращает true в случае успеха.

	bool erase(const KeyType&) - Удаляет узел с заданным ключом, возвращает true в случае успеха.
	bool erase(Iterator&) - Удаляет узел, на который указывает итератор, делает итератор невалидным, возвращает true в случае успеха.

	bool setValue(KeyType, ValueType) - Изменяет значение узла с данным ключом на переданное значение, возвращает true в случае успеха.

	Iterator find(KeyType) - Ищет элемент с заданным ключем и возращает итератор на него в случае успеха, в случае неудачи
		возвращает результат метода afterEnd();

	std::vector<std::pair<KeyType, ValueType>> getVector() - Возвращает вектор со всеми узлами в виде пар ключ-значение,
		расположенных в порядке возрастания ключей.

	Iterator beforeBegin() - Возвращет итератор, указывающий на область памяти перед первым узлом. 
	Iterator begin() - Возвращет итератор, указывающий на первый узел.
	Iterator end() - Возвращет итератор, указывающий на последний узел.
	Iterator afterEnd() - Возвращет итератор, указывающий на область памяти после последнего узла.

	void clear() - Удаляет все узлы дерева.


Описание protected/private методов:
	
	Все классы:
	
	void swapNodes(Node*, Node*) - Меняет местами ключ и значение одного узла с ключом и значением другого узла.
		Необходим для алгоритма удаления.

	Node* innerFind(const KeyType&) - Возвращает указатель на узел с переданным ключом в случае успеха
		и nullptr в случае если такой узел не найден.
		Необходим для поиска и удаления.

	Класс AVLTree:

	void calculateHeight(Node*) - Вычисляет высоту переданного узла
	void updateHeight(Node*) - Обновляет высоту всех узлов от переданного до корня
	void getSubTreesHeight(Node*, short&, short&) - Принимает указатель на узел, а также 2 ссылки,
		в первую присваивает высоту левого поддерева, во втрорую высоту правого.

	void leftRotate(Node*) - Совершает левый или большой левый повороты вокруг переданного узла.
	void rightRotate(Node*) - Совершает правый или большой правый повороты вокруг переданного узла.

	void balance(Node*) - Проверяет баланс дерева начиная с переданного узла и при необходимости 
		совершает балансировку.

	Класс RBTree:

	void leftRotate(Node*) - Совершает левый поворот вокруг переданного узла.
	void rightRotate(Node*) - Совершает правый поворот вокруг переданного узла.

	void insertBalance() - Выполняет балансировку дерева после вставки нового узла.
	void eraseBalance(structForEraseBalance&) - Выполняет балансировку дерева после удаления узла.

Описание алгоритмов:
	
	Узлы:
		BasicNode - базовый класс, от которого наследуются классы AVLNode и RBNode.
		Имеет виртуальный методы getHeight(), setHeight(short), getColor(), setColor(char).
		Структура BasicNode:
			KeyType key; - ключ
			ValueType value; - значение

			BasicNode* parent; - указатель на родительский узел.
			BasicNode* left; - указатель на левый дочерний узел.
			BasicNode* right; - указатель на правый дочерний узел.

		AVLNode имеет дополнительное поле short height и переопределяет методы  getHeight(), setHeight(short).
		RBNode имеет дополнительное поле char color и переопределяет методы getColor(), setColor(char)


	Деревья:
		Tree - базовый класс от которого наследуются AVLTree и RBTree.
		Структура Tree:
			BasicNode* root; - Указатель на корень.
			BasicNode* last_added_node; - Указатель на последний добавленный узел.
			BasicNode* parent_of_last_erased_node; - Указатель на родителя последнего удаленного узла.

			TREE_TYPES type; - TREE_TYPES перечисление которое хранит виды деревьев, type хранит вид экземляра класса.
			int m_size; - Хранит количество узлов.

		AVLTree и RBTree не имеют дополнительных полей.

	Вставка нового узла в дерево:
		1.Если корень = nullptr, присваиваем root новый узел. Возвращаем true.
		2.Создаем указатель BasicNode* searchPtr и присваиваем ему корневой узел.
		3.Начинаем бесконечный цикл: 
		-Если _key(переданный ключ) уже есть в searchPtr, вовзращаем false.
		-Если _key больше ключа searchPtr:
			-Если searchPtr->right = nullptr, присваиваем searchPtr->right новый узел.
				Используем switch(type) для коректного выделения памяти в соответсвие с типом дерева.
				Например: AVLNode для AVL дерева.
			-Если searchPtr->right не nullptr, присваиевам searchPtr = searchPtr->right и начинаем новую итерацию.
		-Если _key меньше ключа searchPtr:
			-Если searchPtr->left = nullptr, присваиваем searchPtr->left новый узел.
				Используем switch(type) для коректного выделения памяти в соответсвие с типом дерева.
				Например: AVLNode для AVL дерева.
			-Если searchPtr->left не nullptr, присваиевам searchPtr = searchPtr->left и начинаем новую итерацию.
		4.Для AVL дерева циклом идем по родителям от последнего добавленного узла до корня и обновляем высоту.
			Затем начинаем балансировку.
		  Для RB дерева просто начинаем балансировку. 

	Удаление узла из дерева:
		1